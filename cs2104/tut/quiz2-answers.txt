Quiz 2
======
1. hoo f g x = f (g x) x 
   f: t1 -> t2 -> t3
   g: t2 -> t4  // t4=t1
   x: t2
   hoo : (t1 -> t2 -> t3) -> (t2->t1) -> t2 -> t3
   Ans : (a -> b -> c) -> (b -> a) -> b -> c

2. hoo f x = f x f
   f :: t1 -> t2 -> t3 // but t2 = t1->t2->t3
   x :: t1
   hoo:: (t1 -> t2 -> t3) -> x -> t3
   but t2 = t1->t2->t3 leads to infinite type.
   Hence, this example is untypeable.
   Ans : None of the Given Answers 

3. sM p f xs = case xs of
     []   -> []
     x:xs -> if p x then (f x):(sM p f xs)
             else x:(sM p f xs)
   p :: t1 -> Bool
   f :: t1 -> t1
   xs :: [t1]
   sM :: (t1 -> Bool) -> (t1 -> t1) -> [t1] -> [t1]
   Ans : (a->Bool) -> (a->a) -> [a] -> [a]
   
4. What would be computed by 
  (sM (\x -> x>5) (\x -> x+1) [4,5,9,8,0]) ?
  From code, values >5 will be increased by +1;
  other values are unchanged.
  Hence: [4,5,9,8,0] ==> [4,5,10,9,0]
  Ans : [4,5,10,9,0]

5.  Implement this (sM p f xs) function using foldr instead where
       foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

  Following the code and pattern of foldr, we get:
  
  foldr (\ x r -> 
      if p x then (f x):r 
	  else x:r
  ) [] xs 
  
  Ans : foldr (\ x r -> if p x then (f x):r else x:r) [] xs

6. Consider the following monadic Haskell function:

foo3 [m] x    = m x
foo3 (m:xs) x = m x >>= (\r -> foo3 xs r)

What is the most general type of this method?

foo3 :: Monad m => [t1] -> t2 -> m a
From m x, we have t1 = Monad m => t2 -> m a 
From (\r -> foo3 xs r), we have a = t2
Ans : Monad m => [t2 -> m a] -> t2 -> m a
      Monad m => [a -> m a] -> a -> m a
	  
7. What would be returned by 
   (let f = \a->[a,a+1] in foo3 [f,f] 1) ?

   foo3 [f,f] 1
   ==> f 1 >>= (\r -> foo3 [f] r)
   ==> f 1 >>= (\r -> f r)
   ==> [1,2] >>= (\r -> f r)
   ==> (f 1) ++ (f 2)
   ==> [1,2] ++ [2,3]
   ==> [1,2,2,3]
   
   Ans : [1,2,2,3]

8. What would be returned by

  (let f = \a->((putStr(show (4+a)))>>return (a+1)) 
   in foo3 [f,f] 1) ?
   
   foo3 [f,f] 1
   ==> f 1 >>= (\r -> foo3 [f] r)
   ==> f 1 >>= (\r -> f r)
   ==> ((putStr(show (4+1)))>>return (1+1)) >>=
       (\r -> f r)
   ==> ((putStr(show (4+1)))>> f 2
   ==> ((putStr(show (4+1)))>> ((putStr(show (4+2)))>>return (2+1))
   ==> ((putStr "5")>> ((putStr "6")) >>return (2+1))  
   
   "56"3
   Ans : 563 (Output as viewed on terminal)
   


9. Consider the following grammar rules:
      <S> ::= <A><B> | <C><A> | <A><A>
      <A> ::= 01 | 10 | 1
      <B> ::= 11
      <C> ::= 00

Which of the following is not a member of the language with 
start symbol <S> ?
 001 = <C>1 = <C><A>
 011 = <A>1 = <A><A>
 101 = <A>1 = <A><A>
 111 = <B>1 = <B><A>
 Ans : None of the Given Answers
 
10. 
Consider the following grammar rules:
      <S> ::= <A><B> | <C><A> | <A><A>
      <A> ::= 01 | 10 | 1
      <B> ::= 11
      <C> ::= 00
How many distinct strings can be formed by the language
with start symbol <S> ?

<S> ==> <A><B> | <C><A> | <A><A>
    ==> 01<B> | 10<B> | 1<B> | 00<A> | 01<A> | 10<A> | 1<A> 
	==> 0111 | 1011 | 111 | 00<A> | 01<A> | 10<A> | 1<A>
	==> 0111 | 1011 | 111 
	     | 00<A> 
	     | 01<A> 
		 | 10<A> 
		 | 1<A>
	==> 0111 | 1011 | 111 
	     | 0001 | 0010 | 001 
	     | 0101 | 0110 | 011 
		 | 1001 | 1010 | 101 
		 | 101 | 110 | 11
    ==>    0111 | 1011  
	     | 0001 | 0010  
	     | 0101 | 0110  
		 | 1001 | 1010  
		 | 101 | 110 | 111 | 001 | 011 | 101 (duplicate)
		 | 11
	==> 14 distinct elements
Ans : 14

11. 
Consider the following unification of two Prolog terms
       f(g(a,A),B,d) = f(C,g(c),D)
Which of the following is not an outcome of this unification?

f(g(a,A),B,d) = f(C,g(c),D)
==> g(a,A)=C /\ B=g(c) /\ D=d

Ans : A=a is not an outcome of above unification

12. 
Consider the following Prolog program
 mixed([],L2,L2).
 mixed(L1,[],L1).
 mixed([H1|T1],[H2|T2],[H1|T3]) :- mixed(T1,[H2|T2],T3).
 mixed([H1|T1],[H2|T2],[H2|T3]) :- mixed([H1|T1],T2,T3).
How many solutions will be generated by the query  
 mixed([1,2],[a,b],R) ?

mixed merges from [1,2] and [a,b] non-deterministically; giving:
  R = [1,2,a,b]
    = [1,a,2,b]
	= [1,a,b,2]
    = [a,1,2,b]
	= [a,1,b,2]
	= [a,b,1,2]
Ans : 6

13. 
Consider the following Prolog program
 mixed([],L2,L2).
 mixed(L1,[],L1).
 mixed([H1|T1],[H2|T2],[H1|T3]) :- mixed(T1,[H2|T2],T3).
 mixed([H1|T1],[H2|T2],[H2|T3]) :- mixed([H1|T1],T2,T3).
Prolog utilizes depth-first search which select clauses 
for unification in a top-down fashion, and processes goals 
in a left-to-right order. Based on this search strategy. 
what is the third solution of the query  
mixed([1,2],[a,b],R) ?

From above sequence, third answer is:
= [1,a,b,2]
Ans : None of the Given Answers

14. 
Consider the following Prolog program
 mixed([],L2,L2).
 mixed(L1,[],L1).
 mixed([H1|T1],[H2|T2],[H1|T3]) :- mixed(T1,[H2|T2],T3).
 mixed([H1|T1],[H2|T2],[H2|T3]) :- mixed([H1|T1],T2,T3).
A query contains redundant solution if it has multiple results 
with identical variable substitutions. Which of the following 
query contains redundant solutions ?

Only mixed([],[],R) would give duplicated answers of R=[] twice.

Ans : mixed([],[],R)

15. 
Consider the following Prolog program
 qoo([X|R],R).
 qoo([X|L],R) :- qoo(L,R).
How many solutions would be returned by the query qoo([1,2,3],R) ?

qoo either one or more elements from first input

 qoo([1,2,3],R)
 ==> R = [2,3]
     R = [3]
	 R = []
Ans : 3


16. 
Consider the following Prolog program
 qoo([X|R],R).
 qoo([X|L],R) :- qoo(L,R).
Which of the following is not a solution of the query qoo(R,[1,2]) ?

qoo(R,[1,2])
 R = [_1,1,2]
   = [_2,_1,1,2]
   = ..
Ans : R=[1,2]

17. 
Consider the following Prolog program
 poo([],0).
 poo([X|Xs],S) :- poo(Xs,R), S is X+R.
Which of the following is valid solution of the query 
poo([3,2,1],R) ?

poo([3,2,1],R)
  :- poo([2,1],R1), R is R1+3
  :- poo([1],R2), R1 is R2+2, R is R1+3
  :- poo([],R3), R2 is R3+1. R1 is R2+2, R is R1+3
  :- R3=0, R2 is R3+1. R1 is R2+2, R is R1+3
  :- R2 is 0+1. R1 is R2+2, R is R1+3
  :- R is 0+1+2+3
  R is 6
Ans : R=6

18. 
Consider the following Prolog program
 poo([],0).
 poo([X|Xs],S) :- poo(Xs,R), S is X+R.
Which of the following is a valid result of the  query  
poo([3,X,1],R) ? 

poo([3,X,1],R)
  :- poo([X,1],R1), R is R1+3
  :- poo([1],R2), R1 is R2+X, R is R1+3
  :- poo([],R3), R2 is R3+1. R1 is R2+2, R is R1+3
  :- R3=0, R2 is R3+1. R1 is R2+X, R is R1+3
  :- R2 is 0+1, R1 is R2+X, R is R1+3
  :- R1 is 1+X, R is R1+3
  // runtime error with X not instantiated
  
Ans : A run-time error is encountered.

19. 
Consider the following Prolog program
 doo([],0).
 doo([_|Xs],S) :- doo(Xs,R), S is 1+R.
Which of the following is a valid result of the  query  
doo([3,X,1],R) ? 

doo([3,X,1],R)
  :- doo([X,1],R1), R is 1+R1
  :- doo([1],R2), R1 is 1+R2, R is 1+R1
  :- doo([],R3), R2 is 1+R3, R1 is 1+R2, R is 1+R1
  :- R3=0, R2 is 1+R3, R1 is 1+R2, R is 1+R1
  :- R is 1+1+1+0
  :- R is 3

Ans : 3	
	
20. 
Consider the following Prolog program
 doo([],0).
 doo([_|Xs],S) :- doo(Xs,R), S is 1+R.
Which is the second result of the  query  doo(R,3) ? 

There is only one answer for this query.
As no constraints were used, infinitelyh longer lists
were being generated for R which leads to the execution going into
a loop:

Ans : An infinite loop was encountered





   

